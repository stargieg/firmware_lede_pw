From 3b97677eda0c5b496cc78cb55a82a1885c842b26 Mon Sep 17 00:00:00 2001
From: Michael Altizer <xiche@verizon.net>
Date: Mon, 26 Dec 2016 16:58:41 -0500
Subject: [PATCH 1/4] Add BTRFS root filesystem support.

---
 config/Config-images.in                            |  6 ++
 include/image.mk                                   |  7 ++
 target/Config.in                                   |  3 +
 tools/Makefile                                     |  4 ++
 tools/btrfs-progs/Makefile                         | 43 ++++++++++++
 ...thread_join-instead-of-pthread_tryjoin_np.patch | 11 ++++
 tools/lzo/Makefile                                 | 37 +++++++++++
 tools/util-linux/Makefile                          | 48 ++++++++++++++
 .../patches/0001-fix-uClibc-ng-scanf-check.patch   | 34 ++++++++++
 .../patches/003-fix_pkgconfig_files.patch          | 76 ++++++++++++++++++++++
 tools/zlib/Makefile                                | 36 ++++++++++
 11 files changed, 305 insertions(+)
 create mode 100644 tools/btrfs-progs/Makefile
 create mode 100644 tools/btrfs-progs/patches/0001-use-pthread_join-instead-of-pthread_tryjoin_np.patch
 create mode 100644 tools/lzo/Makefile
 create mode 100644 tools/util-linux/Makefile
 create mode 100644 tools/util-linux/patches/0001-fix-uClibc-ng-scanf-check.patch
 create mode 100644 tools/util-linux/patches/003-fix_pkgconfig_files.patch
 create mode 100644 tools/zlib/Makefile

diff --git a/config/Config-images.in b/config/Config-images.in
index 8e295939d95..0222ebf24b1 100644
--- a/config/Config-images.in
+++ b/config/Config-images.in
@@ -67,6 +67,12 @@ menu "Target Images"
 
 	comment "Root filesystem images"
 
+	config TARGET_ROOTFS_BTRFS
+		bool "btrfs"
+		default y if USES_BTRFS
+		help
+		  Build a btrfs root filesystem.
+
 	menuconfig TARGET_ROOTFS_EXT4FS
 		bool "ext4"
 		default y if USES_EXT4
diff --git a/include/image.mk b/include/image.mk
index 81519cd1834..03628992aba 100644
--- a/include/image.mk
+++ b/include/image.mk
@@ -95,6 +95,7 @@ fs-types-$(CONFIG_TARGET_ROOTFS_JFFS2_NAND) += $(addprefix jffs2-nand-,$(NAND_BL
 fs-types-$(CONFIG_TARGET_ROOTFS_EXT4FS) += ext4
 fs-types-$(CONFIG_TARGET_ROOTFS_ISO) += iso
 fs-types-$(CONFIG_TARGET_ROOTFS_UBIFS) += ubifs
+fs-types-$(CONFIG_TARGET_ROOTFS_BTRFS) += btrfs
 fs-subtypes-$(CONFIG_TARGET_ROOTFS_JFFS2) += $(addsuffix -raw,$(addprefix jffs2-,$(JFFS2_BLOCKSIZE)))
 
 TARGET_FILESYSTEMS := $(fs-types-y)
@@ -259,6 +260,12 @@ define Image/mkfs/ext4
 		$@ $(call mkfs_target_dir,$(1))/
 endef
 
+define Image/mkfs/btrfs
+	dd if=/dev/zero bs=1M count=$(CONFIG_TARGET_ROOTFS_PARTSIZE) of=$@
+	$(STAGING_DIR_HOST)/bin/mkfs.btrfs -f -m single -d single \
+		-r $(call mkfs_target_dir,$(1))/ $@
+endef
+
 define Image/Manifest
 	$(STAGING_DIR_HOST)/bin/opkg \
 		--offline-root $(TARGET_DIR) \
diff --git a/target/Config.in b/target/Config.in
index 9ff70968801..f34011ec8c3 100644
--- a/target/Config.in
+++ b/target/Config.in
@@ -54,6 +54,9 @@ config USES_JFFS2
 config USES_JFFS2_NAND
 	bool
 
+config USES_BTRFS
+	bool
+
 config USES_EXT4
 	bool
 
diff --git a/tools/Makefile b/tools/Makefile
index 4d338cca630..024699bbccf 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -38,6 +38,7 @@ tools-$(BUILD_B43_TOOLS) += b43-tools
 tools-$(BUILD_ISL) += isl
 tools-$(CONFIG_USE_SPARSE) += sparse
 tools-$(CONFIG_TARGET_apm821xx) += genext2fs
+tools-y += lzo util-linux zlib btrfs-progs
 
 # builddir dependencies
 $(curdir)/bison/compile := $(curdir)/flex/install
@@ -72,6 +73,9 @@ $(curdir)/libressl/compile := $(curdir)/pkg-config/compile
 $(curdir)/mkimage/compile += $(curdir)/libressl/compile
 $(curdir)/firmware-utils/compile += $(curdir)/libressl/compile
 $(curdir)/cmake/compile += $(curdir)/libressl/compile
+$(curdir)/lzo/compile := $(curdir)/libtool/compile
+$(curdir)/util-linux/compile := $(curdir)/libtool/compile
+$(curdir)/btrfs-progs/compile := $(curdir)/util-linux/compile $(curdir)/lzo/compile $(curdir)/zlib/compile
 
 ifneq ($(HOST_OS),Linux)
   tools-y += coreutils
diff --git a/tools/btrfs-progs/Makefile b/tools/btrfs-progs/Makefile
new file mode 100644
index 00000000000..30980487983
--- /dev/null
+++ b/tools/btrfs-progs/Makefile
@@ -0,0 +1,43 @@
+#
+# Copyright (C) 2009-2014 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=btrfs-progs
+PKG_VERSION:=4.7.2
+PKG_RELEASE:=1
+
+PKG_SOURCE:=$(PKG_NAME)-v$(PKG_VERSION).tar.xz
+PKG_SOURCE_URL:=@KERNEL/linux/kernel/people/kdave/btrfs-progs/
+PKG_MD5SUM:=f49bc9e143ffe60260c5bd70ef3b624576673f8b50f41e309892a425f7fbe60f
+
+HOST_BUILD_DIR:=$(BUILD_DIR_HOST)/$(PKG_NAME)-v$(PKG_VERSION)
+
+HOST_BUILD_PARALLEL:=1
+
+HOST_FIXUP:=autoreconf
+
+include $(INCLUDE_DIR)/host-build.mk
+
+HOST_CONFIGURE_ARGS += \
+	--disable-backtrace \
+	--disable-convert \
+	--disable-documentation
+
+define Host/Compile
+	$(call Host/Compile/Default,mkfs.btrfs)
+endef
+
+define Host/Install
+	$(INSTALL_BIN) $(HOST_BUILD_DIR)/mkfs.btrfs $(STAGING_DIR_HOST)/bin/mkfs.btrfs
+endef
+
+define Host/Clean
+	rm -f $(STAGING_DIR_HOST)/bin/mkfs.btrfs
+endef
+
+$(eval $(call HostBuild))
diff --git a/tools/btrfs-progs/patches/0001-use-pthread_join-instead-of-pthread_tryjoin_np.patch b/tools/btrfs-progs/patches/0001-use-pthread_join-instead-of-pthread_tryjoin_np.patch
new file mode 100644
index 00000000000..90b56b49367
--- /dev/null
+++ b/tools/btrfs-progs/patches/0001-use-pthread_join-instead-of-pthread_tryjoin_np.patch
@@ -0,0 +1,11 @@
+--- a/chunk-recover.c
++++ b/chunk-recover.c
+@@ -887,7 +887,7 @@ static int scan_devices(struct recover_c
+ 		for (i = 0; i < devidx; i++) {
+ 			if (dev_scans[i].bytenr == -1)
+ 				continue;
+-			ret = pthread_tryjoin_np(t_scans[i],
++			ret = pthread_join(t_scans[i],
+ 						 (void **)&t_rets[i]);
+ 			if (ret == EBUSY) {
+ 				all_done = 0;
diff --git a/tools/lzo/Makefile b/tools/lzo/Makefile
new file mode 100644
index 00000000000..7ce4d8f454c
--- /dev/null
+++ b/tools/lzo/Makefile
@@ -0,0 +1,37 @@
+#
+# Copyright (C) 2006-2016 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=lzo
+PKG_VERSION:=2.09
+PKG_RELEASE:=1
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_SOURCE_URL:=http://www.oberhumer.com/opensource/lzo/download/
+PKG_HASH:=f294a7ced313063c057c504257f437c8335c41bfeed23531ee4e6a2b87bcb34c
+
+HOST_FIXUP:=autoreconf
+
+HOST_BUILD_PARALLEL:=1
+
+include $(INCLUDE_DIR)/host-build.mk
+
+define Host/Configure
+	$(call Host/Configure/Default, \
+		--enable-shared \
+		--enable-static \
+	)
+endef
+
+define Host/Clean
+	rm -rf $(STAGING_DIR_HOST)/include/lzo
+	rm -f $(STAGING_DIR_HOST)/lib/liblzo2.*
+	rm -rf $(STAGING_DIR_HOST)/share/doc/lzo
+endef
+
+$(eval $(call HostBuild))
diff --git a/tools/util-linux/Makefile b/tools/util-linux/Makefile
new file mode 100644
index 00000000000..f3cfcc55463
--- /dev/null
+++ b/tools/util-linux/Makefile
@@ -0,0 +1,48 @@
+#
+# Copyright (C) 2007-2015 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=util-linux
+PKG_VERSION:=2.28
+PKG_RELEASE:=1
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.xz
+PKG_SOURCE_URL:=@KERNEL/linux/utils/$(PKG_NAME)/v2.28
+PKG_HASH:=395847e2a18a2c317170f238892751e73a57104565344f8644090c8b091014bb
+
+HOST_BUILD_PARALLEL:=0
+
+PKG_FIXUP:=autoreconf
+
+include $(INCLUDE_DIR)/host-build.mk
+
+HOST_CONFIGURE_ARGS += \
+	--disable-all-programs \
+	--enable-libblkid	\
+	--enable-libuuid	\
+	--disable-bash-completion 	\
+	--disable-nls	 	\
+	--disable-rpath 	\
+	--without-ncurses	\
+	--without-python	\
+	--without-readline	\
+	--without-systemd	\
+	--without-udev
+
+HOST_CFLAGS += $(FPIC) -std=gnu99
+
+define Host/Clean
+	rm -rf $(STAGING_DIR_HOST)/include/blkid
+	rm -f $(STAGING_DIR_HOST)/lib/libblkid.*
+	rm -f $(STAGING_DIR_HOST)/lib/pkgconfig/blkid.pc
+	rm -rf $(STAGING_DIR_HOST)/include/uuid
+	rm -f $(STAGING_DIR_HOST)/lib/libuuid.*
+	rm -f $(STAGING_DIR_HOST)/lib/pkgconfig/uuid.pc
+endef
+
+$(eval $(call HostBuild))
diff --git a/tools/util-linux/patches/0001-fix-uClibc-ng-scanf-check.patch b/tools/util-linux/patches/0001-fix-uClibc-ng-scanf-check.patch
new file mode 100644
index 00000000000..2da95f6cdba
--- /dev/null
+++ b/tools/util-linux/patches/0001-fix-uClibc-ng-scanf-check.patch
@@ -0,0 +1,34 @@
+From 180c908e2e80552b19bf3552667fc197d6edf7b3 Mon Sep 17 00:00:00 2001
+From: Waldemar Brodkorb <wbx@uclibc-ng.org>
+Date: Fri, 3 Jun 2016 04:13:08 +0200
+Subject: [PATCH] fix uClibc-ng scanf check
+
+uClibc-ng tries to be compatible with GNU libc and defines
+__GLIBC__ and pretend to be version 2.2.
+We once changed it to 2.10, but then some hard to fix problems
+in different software packages (gcc) occured.
+It would be better if we disable the special GNU libc checks
+for uClibc-ng here. uClibc-ng implements the required scanf
+functionality.
+
+Signed-off-by: Waldemar Brodkorb <wbx@uclibc-ng.org>
+---
+ configure.ac | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/configure.ac b/configure.ac
+index f36b18c..4661c0d 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -581,7 +581,7 @@ AC_CACHE_VAL([scanf_cv_alloc_modifier],
+      #include <stdio.h>
+      #include <unistd.h>
+ 
+-     #ifdef __GLIBC__
++     #if defined(__GLIBC__) && !defined(__UCLIBC__)
+ 
+      #if !(__GLIBC_PREREQ(2, 7))
+      #error %m is not available
+-- 
+2.1.4
+
diff --git a/tools/util-linux/patches/003-fix_pkgconfig_files.patch b/tools/util-linux/patches/003-fix_pkgconfig_files.patch
new file mode 100644
index 00000000000..cc9cd11188a
--- /dev/null
+++ b/tools/util-linux/patches/003-fix_pkgconfig_files.patch
@@ -0,0 +1,76 @@
+--- a/libuuid/Makemodule.am
++++ b/libuuid/Makemodule.am
+@@ -4,7 +4,6 @@ include libuuid/man/Makemodule.am
+ include libuuid/src/Makemodule.am
+ 
+ pkgconfig_DATA += libuuid/uuid.pc
+-PATHFILES      += libuuid/uuid.pc
+ EXTRA_DIST     += libuuid/COPYING
+ 
+ endif # BUILD_LIBUUID
+--- a/configure.ac
++++ b/configure.ac
+@@ -2122,18 +2122,23 @@ AC_CONFIG_HEADERS([config.h])
+ #
+ AC_CONFIG_FILES([
+ Makefile
++libblkid/blkid.pc
+ libblkid/docs/Makefile
+ libblkid/docs/version.xml
+ libblkid/src/blkid.h
++libfdisk/fdisk.pc
+ libfdisk/docs/Makefile
+ libfdisk/docs/version.xml
+ libfdisk/src/libfdisk.h
++libmount/mount.pc
+ libmount/docs/Makefile
+ libmount/docs/version.xml
+ libmount/src/libmount.h
++libsmartcols/smartcols.pc
+ libsmartcols/docs/Makefile
+ libsmartcols/docs/version.xml
+ libsmartcols/src/libsmartcols.h
++libuuid/uuid.pc
+ po/Makefile.in
+ ])
+ 
+--- a/libblkid/Makemodule.am
++++ b/libblkid/Makemodule.am
+@@ -9,7 +9,6 @@ SUBDIRS += libblkid/docs
+ endif
+ 
+ pkgconfig_DATA += libblkid/blkid.pc
+-PATHFILES      += libblkid/blkid.pc
+ dist_man_MANS  += libblkid/libblkid.3
+ EXTRA_DIST     += libblkid/libblkid.3 libblkid/COPYING
+ 
+--- a/libmount/Makemodule.am
++++ b/libmount/Makemodule.am
+@@ -9,7 +9,6 @@ SUBDIRS += libmount/docs
+ endif
+ 
+ pkgconfig_DATA += libmount/mount.pc
+-PATHFILES      += libmount/mount.pc
+ EXTRA_DIST     += libmount/COPYING
+ 
+ endif # BUILD_LIBMOUNT
+--- a/libsmartcols/Makemodule.am
++++ b/libsmartcols/Makemodule.am
+@@ -9,7 +9,6 @@ SUBDIRS += libsmartcols/docs
+ endif
+ 
+ pkgconfig_DATA += libsmartcols/smartcols.pc
+-PATHFILES      += libsmartcols/smartcols.pc
+ EXTRA_DIST     += libsmartcols/COPYING
+ 
+ endif # BUILD_LIBSMARTCOLS
+--- a/libfdisk/Makemodule.am
++++ b/libfdisk/Makemodule.am
+@@ -8,7 +8,6 @@ SUBDIRS += libfdisk/docs
+ endif
+ 
+ pkgconfig_DATA += libfdisk/fdisk.pc
+-PATHFILES      += libfdisk/fdisk.pc
+ EXTRA_DIST     += libfdisk/COPYING
+ 
+ endif # BUILD_LIBFDISK
diff --git a/tools/zlib/Makefile b/tools/zlib/Makefile
new file mode 100644
index 00000000000..7837036c0f5
--- /dev/null
+++ b/tools/zlib/Makefile
@@ -0,0 +1,36 @@
+#
+# Copyright (C) 2006-2013 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=zlib
+PKG_VERSION:=1.2.8
+PKG_RELEASE:=1
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_SOURCE_URL:=http://www.zlib.net @SF/libpng
+PKG_HASH:=36658cb768a54c1d4dec43c3116c27ed893e88b02ecfcb44f2166f9c0b7f2a0d
+
+include $(INCLUDE_DIR)/host-build.mk
+
+define Host/Configure
+	(cd $(HOST_BUILD_DIR); \
+		./configure \
+			--prefix=$(STAGING_DIR_HOST) \
+			--shared \
+			--uname=Linux \
+	)
+endef
+
+define Host/Clean
+	rm -f $(STAGING_DIR_HOST)/include/zlib.h
+	rm -f $(STAGING_DIR_HOST)/lib/libz.*
+	rm -f $(STAGING_DIR_HOST)/lib/pkgconfig/zlib.pc
+	rm -f $(STAGING_DIR_HOST)/share/man/man3/zlib.3
+endef
+
+$(eval $(call HostBuild))

From c91525516cac8a15024730af219c87d0009609db Mon Sep 17 00:00:00 2001
From: Michael Altizer <xiche@verizon.net>
Date: Mon, 26 Dec 2016 16:59:58 -0500
Subject: [PATCH 2/4] Initial Turris Omnia support.

---
 .../linux/generic/files/drivers/net/phy/mvsw61xx.c |  23 +-
 .../linux/generic/files/drivers/net/phy/mvsw61xx.h |   3 +
 .../linux/mvebu/base-files/etc/board.d/02_network  |   5 +
 target/linux/mvebu/base-files/lib/mvebu.sh         |   3 +
 target/linux/mvebu/config-4.4                      |  12 +-
 .../arch/arm/boot/dts/armada-385-turris-omnia.dts  | 343 +++++++++++++++++++++
 target/linux/mvebu/image/Makefile                  |   9 +
 .../mvebu/patches-4.4/400-add_omnia_dtb.patch      |  12 +
 8 files changed, 403 insertions(+), 7 deletions(-)
 create mode 100644 target/linux/mvebu/files/arch/arm/boot/dts/armada-385-turris-omnia.dts
 create mode 100644 target/linux/mvebu/patches-4.4/400-add_omnia_dtb.patch

diff --git a/target/linux/generic/files/drivers/net/phy/mvsw61xx.c b/target/linux/generic/files/drivers/net/phy/mvsw61xx.c
index 9a689e6c81b..bf3f17c8eb9 100644
--- a/target/linux/generic/files/drivers/net/phy/mvsw61xx.c
+++ b/target/linux/generic/files/drivers/net/phy/mvsw61xx.c
@@ -670,16 +670,29 @@ static int _mvsw61xx_reset(struct switch_dev *dev, bool full)
 					    BMCR_SPEED1000);
 		}
 
-		/* enable SerDes if necessary */
-		if (full && i >= 5 && state->model == MV_IDENT_VALUE_6176) {
+		if (state->model == MV_IDENT_VALUE_6176) {
 			u16 sts = sr16(dev, MV_PORTREG(STATUS, i));
 			u16 mode = sts & MV_PORT_STATUS_CMODE_MASK;
 
-			if (mode == MV_PORT_STATUS_CMODE_100BASE_X ||
-			    mode == MV_PORT_STATUS_CMODE_1000BASE_X ||
-			    mode == MV_PORT_STATUS_CMODE_SGMII) {
+			printk(KERN_INFO "%s: Port %d has status 0x%hx\n", __func__, i, sts);
+			/* enable SerDes if necessary */
+			if (i >= 5 && full &&
+				(mode == MV_PORT_STATUS_CMODE_100BASE_X ||
+				 mode == MV_PORT_STATUS_CMODE_1000BASE_X ||
+				 mode == MV_PORT_STATUS_CMODE_SGMII)) {
 				mvsw61xx_enable_serdes(dev);
 			}
+			/* Enable RGMII internal delay for CPU ports */
+			if (i == state->cpu_port0 || i == state->cpu_port1) {
+				u16 reg = sr16(dev, MV_PORTREG(PHYCTL, i));
+				if ((reg & (MV_PHYCTL_RGMII_DELAY_RXCLK | MV_PHYCTL_RGMII_DELAY_TXCLK)) !=
+					(MV_PHYCTL_RGMII_DELAY_RXCLK | MV_PHYCTL_RGMII_DELAY_TXCLK))
+				{
+					printk(KERN_INFO "%s: Enabling RGMII internal delay for port %d\n", __func__, i);
+					reg |= MV_PHYCTL_RGMII_DELAY_RXCLK | MV_PHYCTL_RGMII_DELAY_TXCLK;
+					sw16(dev, MV_PORTREG(PHYCTL, i), reg);
+				}
+			}
 		}
 	}
 
diff --git a/target/linux/generic/files/drivers/net/phy/mvsw61xx.h b/target/linux/generic/files/drivers/net/phy/mvsw61xx.h
index a07b09cd14c..bbb81c2682a 100644
--- a/target/linux/generic/files/drivers/net/phy/mvsw61xx.h
+++ b/target/linux/generic/files/drivers/net/phy/mvsw61xx.h
@@ -46,6 +46,7 @@ enum {
 enum {
 	MV_PORT_STATUS_FDX		= (1 << 10),
 	MV_PORT_STATUS_LINK		= (1 << 11),
+	MV_PORT_STATUS_PHY_DETECT	= (1 << 12),
 };
 
 enum {
@@ -78,6 +79,8 @@ enum {
 enum {
 	MV_PHYCTL_FC_ENABLE		= (3 << 6),
 	MV_PHYCTL_FC_DISABLE		= (1 << 6),
+	MV_PHYCTL_RGMII_DELAY_TXCLK	= (1 << 14),
+	MV_PHYCTL_RGMII_DELAY_RXCLK	= (1 << 15),
 };
 
 enum {
diff --git a/target/linux/mvebu/base-files/etc/board.d/02_network b/target/linux/mvebu/base-files/etc/board.d/02_network
index f4a87efc914..a6976a2fea0 100755
--- a/target/linux/mvebu/base-files/etc/board.d/02_network
+++ b/target/linux/mvebu/base-files/etc/board.d/02_network
@@ -33,6 +33,11 @@ armada-388-clearfog)
 		ucidef_add_switch "switch0" \
 			"0:lan:5" "1:lan:4" "2:lan:3" "3:lan:2" "4:lan:1" "5@eth0" "6:lan:6"
 	;;
+armada-385-turris-omnia)
+	ucidef_set_interfaces_lan_wan "eth0 eth2" "eth1"
+	ucidef_add_switch "switch0" \
+		"0:lan:0" "1:lan:1" "2:lan:2" "3:lan:3" "4:lan:4" "5@eth0" "6@eth2"
+	;;
 *)
 	ucidef_set_interface_lan "eth0"
 	;;
diff --git a/target/linux/mvebu/base-files/lib/mvebu.sh b/target/linux/mvebu/base-files/lib/mvebu.sh
index 9a4c53ed40c..da3ac83cf7e 100755
--- a/target/linux/mvebu/base-files/lib/mvebu.sh
+++ b/target/linux/mvebu/base-files/lib/mvebu.sh
@@ -56,6 +56,9 @@ mvebu_board_detect() {
 	*"SolidRun Clearfog A1")
 		name="armada-388-clearfog"
 		;;
+	*"Turris Omnia")
+		name="armada-385-turris-omnia"
+		;;
 	esac
 
 	[ -z "$name" ] && name="unknown"
diff --git a/target/linux/mvebu/config-4.4 b/target/linux/mvebu/config-4.4
index d8199707b11..8f88e882c62 100644
--- a/target/linux/mvebu/config-4.4
+++ b/target/linux/mvebu/config-4.4
@@ -146,7 +146,6 @@ CONFIG_DMA_ENGINE=y
 CONFIG_DMA_ENGINE_RAID=y
 CONFIG_DMA_OF=y
 CONFIG_DTC=y
-# CONFIG_DW_DMAC_PCI is not set
 CONFIG_EARLY_PRINTK=y
 CONFIG_EDAC_ATOMIC_SCRUB=y
 CONFIG_EDAC_SUPPORT=y
@@ -176,11 +175,14 @@ CONFIG_GENERIC_STRNCPY_FROM_USER=y
 CONFIG_GENERIC_STRNLEN_USER=y
 CONFIG_GLOB=y
 CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_IRQCHIP=y
 CONFIG_GPIO_DEVRES=y
+CONFIG_GPIO_GENERIC=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
 CONFIG_GPIO_MVEBU=y
 CONFIG_GPIO_MVEBU_PWM=y
 CONFIG_GPIO_PCA953X=y
-# CONFIG_GPIO_PCA953X_IRQ is not set
+CONFIG_GPIO_PCA953X_IRQ=y
 CONFIG_GPIO_SYSFS=y
 CONFIG_HANDLE_DOMAIN_IRQ=y
 CONFIG_HARDIRQS_SW_RESEND=y
@@ -238,8 +240,11 @@ CONFIG_HWMON=y
 CONFIG_HZ_FIXED=0
 CONFIG_HZ_PERIODIC=y
 CONFIG_I2C=y
+CONFIG_I2C_ARB_GPIO_CHALLENGE=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_GPIO=y
 CONFIG_I2C_MV64XXX=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_IOMMU_HELPER=y
@@ -270,6 +275,8 @@ CONFIG_MAGIC_SYSRQ=y
 CONFIG_MANGLE_BOOTARGS=y
 CONFIG_MARVELL_PHY=y
 CONFIG_MDIO_BOARDINFO=y
+CONFIG_MDIO_BUS_MUX=y
+CONFIG_MDIO_BUS_MUX_GPIO=y
 CONFIG_MDIO_I2C=y
 CONFIG_MEMORY=y
 CONFIG_MIGHT_HAVE_CACHE_L2X0=y
@@ -333,6 +340,7 @@ CONFIG_OLD_SIGSUSPEND3=y
 CONFIG_ORION_WATCHDOG=y
 CONFIG_OUTER_CACHE=y
 CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_PADATA=y
 CONFIG_PAGE_OFFSET=0xC0000000
 CONFIG_PCI=y
 # CONFIG_PCI_DOMAINS_GENERIC is not set
diff --git a/target/linux/mvebu/files/arch/arm/boot/dts/armada-385-turris-omnia.dts b/target/linux/mvebu/files/arch/arm/boot/dts/armada-385-turris-omnia.dts
new file mode 100644
index 00000000000..aedff5e945a
--- /dev/null
+++ b/target/linux/mvebu/files/arch/arm/boot/dts/armada-385-turris-omnia.dts
@@ -0,0 +1,343 @@
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include "armada-385.dtsi"
+
+/ {
+	model = "Turris Omnia";
+	compatible = "marvell,armada385","marvell,armada380";
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+		stdout-path = &uart0;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x40000000>; /* 1024 MB */
+	};
+
+	soc {
+		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000
+			  MBUS_ID(0x01, 0x1d) 0 0xfff00000 0x100000
+			  MBUS_ID(0x09, 0x19) 0 0xf1100000 0x10000
+			  MBUS_ID(0x09, 0x15) 0 0xf1110000 0x10000>;
+
+		internal-regs {
+			sdhci@d8000 {
+				status = "okay";
+				bus-width = <8>;
+				no-1-8-v;
+				non-removable;
+			};
+
+			sata@a8000 {
+				status = "okay";
+			};
+
+			/* USB part of the eSATA/USB 2.0 port */
+			usb@58000 {
+				status = "okay";
+			};
+
+			/* 2x external USB3 */
+			usb3@f0000 {
+				status = "okay";
+			};
+
+			usb3@f8000 {
+				status = "okay";
+			};
+		};
+
+		pcie-controller {
+			status = "okay";
+
+			pcie@1,0 {
+				/* Port 0, Lane 0 */
+				status = "okay";
+			};
+
+			pcie@2,0 {
+				/* Port 2, Lane 0 */
+				status = "okay";
+			};
+
+			pcie@3,0 {
+				/* Port 3, Lane 0 */
+				status = "okay";
+			};
+
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		button@212 {
+			label = "mcuint";
+			linux,code = <BTN_MISC>;
+			gpios = <&gpio1 11 GPIO_ACTIVE_LOW>;
+			debounce-interval = <0>;
+		};
+	};
+
+	mvsw61xx {
+		status = "okay";
+		compatible = "marvell,88e6176";
+		reg = <0x10>;
+		is-indirect;
+		mii-bus = <&mdio>;
+		cpu-port-0 = <5>;
+		cpu-port-1 = <6>;
+
+		/* IRQ connected to MPP45. */
+		/* interrupt-parent = <&gpio1>;
+		interrupts = <13 IRQ_TYPE_LEVEL_LOW>; */
+	};
+};
+
+&spi0 {
+	status = "okay";
+
+	spi-nor@0 {
+		compatible = "spansion,s25fl164k", "jedec,spi-nor";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0>;
+		spi-max-frequency = <40000000>;
+
+		partition@0 {
+			reg = <0x0 0x00100000>;
+			label = "U-Boot";
+		};
+		partition@1 {
+			reg = <0x00100000 0x00700000>;
+			label = "Rescue system";
+		};
+
+	};
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+
+	i2cmux@70 {
+		compatible = "nxp,pca9547";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x70>;
+		status = "okay";
+		i2c@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0>;
+			status = "okay";
+
+			/* Config memory */
+			eeprom@54 {
+				compatible = "at,24c64";
+				reg = <0x54>;
+			};
+
+			/* Additional device: STM-32, address 0x2a, INT on 43. */
+			leds@2b {
+				compatible = "turris-leds,omnia";
+				reg = <0x2b>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				led0 {
+					label = "user2";
+					reg = <0x0>;
+				};
+
+				led1 {
+					label = "user1";
+					reg = <0x1>;
+				};
+
+				led2 {
+					label = "pci3";
+					reg = <0x2>;
+				};
+
+				led3 {
+					label = "pci2";
+					reg = <0x3>;
+				};
+
+				led4 {
+					label = "pci1";
+					reg = <0x4>;
+				};
+
+				led5 {
+					label = "wan";
+					reg = <0x5>;
+				};
+
+				led6 {
+					label = "lan4";
+					reg = <0x6>;
+				};
+
+				led7 {
+					label = "lan3";
+					reg = <0x7>;
+				};
+
+				led8 {
+					label = "lan2";
+					reg = <0x8>;
+				};
+
+				led9 {
+					label = "lan1";
+					reg = <0x9>;
+				};
+
+				led10 {
+					label = "lan0";
+					reg = <0xa>;
+				};
+
+				led11 {
+					label = "power";
+					reg = <0xb>;
+				};
+
+				led12 {
+					label = "all";
+					reg = <0xc>;
+				};
+			};
+		};
+
+		i2c@1 {
+			/* SATA */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+		};
+
+		i2c@2 {
+			/* PCI 1 */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <2>;
+		};
+
+		i2c@3 {
+			/* PCI 0 */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <3>;
+		};
+
+		i2c@4 {
+			/* SFP */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <4>;
+		};
+
+		i2c@5 {
+			/* ATSHA */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <5>;
+		};
+
+		i2c@6 {
+			/* User GPIO header */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <6>;
+		};
+
+		i2c@7 {
+			/* SFP+ GPIO expander */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <7>;
+
+			sfpgpio: gpio@71 {
+				compatible = "nxp,pca9538";
+				reg = <0x71>;
+				interrupt-parent = <&gpio1>;
+				interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
+	status = "okay";
+};
+
+&mdio {
+	status = "okay";
+
+	phy1: phy@1 {
+		status = "okay";
+		compatible = "marvell,88E1514", "marvell,88E1510", "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+		/* IRQ connected to MPP46. */
+		/* interrupt-parent = <&gpio1>;
+		interrupts = <14 IRQ_TYPE_LEVEL_LOW>; */
+	};
+};
+
+&eth0 {
+	status = "okay";
+	pinctrl-0 = <&ge0_rgmii_pins>;
+	phy-mode = "rgmii-id";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&ge1_rgmii_pins>;
+	phy-mode = "rgmii-id";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&eth2 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy = <&phy1>;
+};
+
+&pinctrl {
+	user_pin: user-pin {
+		marvell,pins = "mpp18", "mpp33", "mpp34", "mpp35", "mpp36",
+				"mpp42", "mpp44", "mpp47", "mpp51", "mpp56";
+		marvell,function = "gpio";
+	};
+};
+
diff --git a/target/linux/mvebu/image/Makefile b/target/linux/mvebu/image/Makefile
index d4596c5935f..c3faaa17cd7 100644
--- a/target/linux/mvebu/image/Makefile
+++ b/target/linux/mvebu/image/Makefile
@@ -189,4 +189,13 @@ define Device/globalscale-mirabox
 endef
 TARGET_DEVICES += globalscale-mirabox
 
+define Device/turris-omnia
+  $(Device/NAND-256K)
+  DEVICE_DTS := armada-385-turris-omnia
+  DEVICE_TITLE := Turris Omnia
+  DEVICE_PACKAGES := kmod-mmc kmod-usb3 kmod-usb-storage kmod-i2c-core \
+	kmod-ath9k kmod-ath10k ath10k-firmware-qca988x btrfs-progs
+endef
+TARGET_DEVICES += turris-omnia
+
 $(eval $(call BuildImage))
diff --git a/target/linux/mvebu/patches-4.4/400-add_omnia_dtb.patch b/target/linux/mvebu/patches-4.4/400-add_omnia_dtb.patch
new file mode 100644
index 00000000000..e3feb95f69d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.4/400-add_omnia_dtb.patch
@@ -0,0 +1,12 @@
+diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
+index 8365e3e..a444db1 100644
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -749,6 +749,7 @@ dtb-$(CONFIG_MACH_ARMADA_38X) += \
+ 	armada-385-linksys-caiman.dtb \
+ 	armada-385-linksys-cobra.dtb \
+ 	armada-385-linksys-shelby.dtb \
++	armada-385-turris-omnia.dts \
+ 	armada-388-clearfog.dtb \
+ 	armada-388-db.dtb \
+ 	armada-388-gp.dtb \

From 720a6e9b2fcf629da87012410404ca802240d4d0 Mon Sep 17 00:00:00 2001
From: Michael Altizer <xiche@verizon.net>
Date: Wed, 28 Dec 2016 03:21:08 -0500
Subject: [PATCH 3/4] omnia: Add more drivers for I2C, LEDs, EEPROM, etc.

---
 target/linux/mvebu/config-4.4                      |  11 +
 .../linux/mvebu/patches-4.4/401-omnia-leds.patch   | 524 +++++++++++++++++++++
 2 files changed, 535 insertions(+)
 create mode 100644 target/linux/mvebu/patches-4.4/401-omnia-leds.patch

diff --git a/target/linux/mvebu/config-4.4 b/target/linux/mvebu/config-4.4
index 8f88e882c62..337a310d392 100644
--- a/target/linux/mvebu/config-4.4
+++ b/target/linux/mvebu/config-4.4
@@ -149,6 +149,7 @@ CONFIG_DTC=y
 CONFIG_EARLY_PRINTK=y
 CONFIG_EDAC_ATOMIC_SCRUB=y
 CONFIG_EDAC_SUPPORT=y
+CONFIG_EEPROM_AT24=y
 CONFIG_EXT4_FS=y
 # CONFIG_F2FS_CHECK_FS is not set
 CONFIG_F2FS_FS=y
@@ -167,6 +168,7 @@ CONFIG_GENERIC_IO=y
 CONFIG_GENERIC_IRQ_CHIP=y
 CONFIG_GENERIC_IRQ_SHOW=y
 CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_MSI_IRQ=y
 CONFIG_GENERIC_PCI_IOMAP=y
 CONFIG_GENERIC_PHY=y
 CONFIG_GENERIC_SCHED_CLOCK=y
@@ -240,11 +242,17 @@ CONFIG_HWMON=y
 CONFIG_HZ_FIXED=0
 CONFIG_HZ_PERIODIC=y
 CONFIG_I2C=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCA=y
+CONFIG_I2C_ALGOPCF=y
 CONFIG_I2C_ARB_GPIO_CHALLENGE=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DEBUG_BUS=y
 CONFIG_I2C_MUX=y
 CONFIG_I2C_MUX_GPIO=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_MUX_PINCTRL=y
 CONFIG_I2C_MV64XXX=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_IOMMU_HELPER=y
@@ -257,6 +265,7 @@ CONFIG_IRQ_WORK=y
 # CONFIG_IWMMXT is not set
 CONFIG_JBD2=y
 CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_OMNIA=y
 CONFIG_LEDS_PCA963X=y
 CONFIG_LEDS_TLC591XX=y
 CONFIG_LIBFDT=y
@@ -277,6 +286,7 @@ CONFIG_MARVELL_PHY=y
 CONFIG_MDIO_BOARDINFO=y
 CONFIG_MDIO_BUS_MUX=y
 CONFIG_MDIO_BUS_MUX_GPIO=y
+CONFIG_MDIO_BUS_MUX_MMIOREG=y
 CONFIG_MDIO_I2C=y
 CONFIG_MEMORY=y
 CONFIG_MIGHT_HAVE_CACHE_L2X0=y
@@ -344,6 +354,7 @@ CONFIG_PADATA=y
 CONFIG_PAGE_OFFSET=0xC0000000
 CONFIG_PCI=y
 # CONFIG_PCI_DOMAINS_GENERIC is not set
+CONFIG_PCI_MSI=y
 CONFIG_PCI_MVEBU=y
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PGTABLE_LEVELS=2
diff --git a/target/linux/mvebu/patches-4.4/401-omnia-leds.patch b/target/linux/mvebu/patches-4.4/401-omnia-leds.patch
new file mode 100644
index 00000000000..e2c4042e2eb
--- /dev/null
+++ b/target/linux/mvebu/patches-4.4/401-omnia-leds.patch
@@ -0,0 +1,524 @@
+commit 1e70bc11fe2f3b30ab7ab11bbba73a84fd0bbe52
+Author: Michael Altizer <xiche@verizon.net>
+Date:   Sun Dec 25 19:55:25 2016 -0500
+
+    Omnia: Add LED driver for MCU LED driver
+    
+    Turris Omnia board have sophisticated and unfotunatelly completely
+    proprietary I2C LED driver implemented in the MCU on the board.
+    
+    The I2C protocol description will be published in
+    https://www.turris.cz/en/hardware .
+    
+    Add driver called leds-omnia that implements LED interface and
+    adds sysfs files for setting:
+    
+    global_brightness - [0..100] = PWM base for all the LEDs. It is the
+    maximum intensity. Particular colors on each LED might be decreased
+    individually.
+    
+    color - [0..255] [0..255] [0..255] = PWM for each color on each LED.
+    
+    autonomous [0|1] = 1=MCU drives the LED according to its default
+    function, blink from Linux LED driver is ignored;
+    0=Linux LED driver sets brightness/blink.
+    
+    brightness = Linux LED interface. Only two states are available
+    0=OFF and 1..255=ON.
+    
+    The MCU supports setting all LEDs at once by setting the virtual
+    12th LED. Support this feature in the kernel driver.
+
+diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
+index b1ab8bd..b3d5c8b 100644
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -568,6 +568,13 @@ config LEDS_SEAD3
+ 
+ comment "LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)"
+ 
++config LEDS_OMNIA
++       tristate "LED support for the Turris Omnia board"
++       depends on LEDS_CLASS
++       help
++         Say Y here to include support for the LED driver on Turris Omnia
++         board.
++
+ config LEDS_BLINKM
+ 	tristate "LED support for the BlinkM I2C RGB LED"
+ 	depends on LEDS_CLASS
+diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
+index 392247a..f09d830 100644
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -66,6 +66,7 @@ obj-$(CONFIG_LEDS_MENF21BMC)		+= leds-menf21bmc.o
+ obj-$(CONFIG_LEDS_KTD2692)		+= leds-ktd2692.o
+ obj-$(CONFIG_LEDS_POWERNV)		+= leds-powernv.o
+ obj-$(CONFIG_LEDS_SEAD3)		+= leds-sead3.o
++obj-$(CONFIG_LEDS_OMNIA)               += leds-omnia.o
+ 
+ # LED SPI Drivers
+ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
+diff --git a/drivers/leds/leds-omnia.c b/drivers/leds/leds-omnia.c
+new file mode 100644
+index 0000000..defa585
+--- /dev/null
++++ b/drivers/leds/leds-omnia.c
+@@ -0,0 +1,457 @@
++/*
++ * Copyright 2016 CZ.NIC, z.s.p.o.
++ *
++ * Author: Tomas Hlavacek <tmshlvck@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation. 
++ */
++
++#include <linux/module.h>
++#include <linux/delay.h>
++#include <linux/string.h>
++#include <linux/ctype.h>
++#include <linux/leds.h>
++#include <linux/err.h>
++#include <linux/i2c.h>
++#include <linux/slab.h>
++#include <linux/of.h>
++#include <linux/workqueue.h>
++
++#define MAX_LEDS 13
++#define ALL_LEDS_INDEX 12
++
++#define LED_AUTONOMOUS_ADDR 3
++#define LED_ONOFF_ADDR 4
++#define LED_COLOR_ADDR 5
++#define GLOB_BRIGHTNESS_READ 8
++#define GLOB_BRIGHTNESS_WRITE 7
++
++
++
++struct omnia_platform_data {
++        struct led_platform_data leds;
++};
++
++static const struct i2c_device_id omnia_id[] = {
++	{ "omnia", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, omnia_id);
++
++struct omnia_led_mcu {
++	struct mutex mutex;
++	struct i2c_client *client;
++	struct omnia_led *leds;
++};
++
++struct omnia_led {
++	struct omnia_led_mcu *chip;
++	struct led_classdev led_cdev;
++	int led_num; /* 0 .. 11 + 12=ALL */
++	char name[32];
++	u8 autonomous;
++	u8 r;
++	u8 g;
++	u8 b;
++	struct work_struct work;
++	enum led_brightness new_brightness;
++};
++
++static int omnia_led_brightness_set(struct omnia_led *led,
++				enum led_brightness brightness)
++{
++	int ret;
++
++	mutex_lock(&led->chip->mutex);
++
++	ret = i2c_smbus_write_byte_data(led->chip->client, LED_ONOFF_ADDR,
++			(led->led_num | ((brightness != LED_OFF)<<4)));
++
++	mutex_unlock(&led->chip->mutex);
++	return ret;
++}
++
++static int omnia_led_autonomous_set(struct omnia_led *led, int autonomous)
++{
++	int ret, i;
++
++	mutex_lock(&led->chip->mutex);
++
++	if (led->autonomous == (autonomous != 0)) {
++		mutex_unlock(&led->chip->mutex);
++		return 0;
++	}
++
++	led->autonomous = (autonomous != 0);
++
++	if (led->led_num == ALL_LEDS_INDEX) {
++		for (i=0; i<(MAX_LEDS-1); i++)
++			led->chip->leds[i].autonomous = led->autonomous;
++	}
++
++	ret = i2c_smbus_write_byte_data(led->chip->client, LED_AUTONOMOUS_ADDR,
++			(u8)(led->led_num | ((!led->autonomous) << 4)));
++
++	mutex_unlock(&led->chip->mutex);
++	return ret;
++}
++
++static int omnia_glob_brightness_set(struct omnia_led_mcu *chip,
++					int glob_brightness)
++{
++	int ret;
++
++	mutex_lock(&chip->mutex);
++
++	ret = i2c_smbus_write_byte_data(chip->client, GLOB_BRIGHTNESS_WRITE,
++						(u8)glob_brightness);
++
++	mutex_unlock(&chip->mutex);
++	return ret;
++}
++
++static int omnia_glob_brightness_get(struct omnia_led_mcu *chip)
++{
++	int ret;
++
++	mutex_lock(&chip->mutex);
++
++	ret = i2c_smbus_read_byte_data(chip->client, GLOB_BRIGHTNESS_READ);
++
++	mutex_unlock(&chip->mutex);
++	return ret;
++}
++
++static int omnia_led_color_set(struct omnia_led *led, u8 r, u8 g, u8 b)
++{
++	int ret, i;
++	u8 buf[5];
++
++	buf[0] = LED_COLOR_ADDR;
++	buf[1] = led->led_num;
++	buf[2] = r;
++	buf[3] = g;
++	buf[4] = b;
++
++	mutex_lock(&led->chip->mutex);
++
++	ret = i2c_master_send(led->chip->client, buf, 5);
++
++	if (led->led_num == ALL_LEDS_INDEX) {
++		for (i=0; i<(MAX_LEDS-1); i++) {
++			led->chip->leds[i].r = led->r;
++			led->chip->leds[i].g = led->g;
++			led->chip->leds[i].b = led->b;
++		}
++	}
++
++	mutex_unlock(&led->chip->mutex);
++	return -(ret<=0);
++}
++
++static void omnia_led_set_async(struct led_classdev *led_cdev,
++        enum led_brightness value)
++{
++	struct omnia_led *led =
++		container_of(led_cdev, struct omnia_led, led_cdev);
++
++	led->new_brightness = value;
++
++	schedule_work(&led->work);
++}
++
++static void omnia_led_work(struct work_struct *work)
++{
++        struct omnia_led *led;
++        led = container_of(work, struct omnia_led, work);
++
++        omnia_led_brightness_set(led, led->new_brightness);
++}
++
++static struct omnia_platform_data *
++omnia_dt_init(struct i2c_client *client)
++{
++	struct device_node *np = client->dev.of_node, *child;
++	struct omnia_platform_data *pdata;
++	struct led_info *leds;
++	int count;
++
++	count = of_get_child_count(np);
++	if (!count || count > MAX_LEDS)
++		return ERR_PTR(-ENODEV);
++
++	leds = devm_kzalloc(&client->dev,
++			sizeof(struct led_info) * MAX_LEDS, GFP_KERNEL);
++	if (!leds)
++		return ERR_PTR(-ENOMEM);
++
++	for_each_child_of_node(np, child) {
++		u32 reg;
++		int res;
++
++		res = of_property_read_u32(child, "reg", &reg);
++		if ((res != 0) || (reg >= MAX_LEDS))
++			continue;
++		leds[reg].name =
++			of_get_property(child, "label", NULL) ? : child->name;
++		leds[reg].default_trigger =
++			of_get_property(child, "linux,default-trigger", NULL);
++	}
++	pdata = devm_kzalloc(&client->dev,
++			     sizeof(struct omnia_platform_data), GFP_KERNEL);
++	if (!pdata)
++		return ERR_PTR(-ENOMEM);
++
++	pdata->leds.leds = leds;
++	pdata->leds.num_leds = MAX_LEDS;
++
++	return pdata;
++}
++
++static ssize_t global_brightness_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct i2c_client *client = to_i2c_client(d);
++	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++
++	return scnprintf(buf, PAGE_SIZE, "%d\n",
++				omnia_glob_brightness_get(chip));
++}
++
++static ssize_t global_brightness_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	struct i2c_client *client = to_i2c_client(d);
++        struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++	int ret;
++	int global_brightness;
++
++	if ((sscanf(buf, "%i", &global_brightness)) != 1)
++		return -EINVAL;
++
++	ret = omnia_glob_brightness_set(chip, global_brightness);
++	if (ret < 0)
++		return ret;
++
++	return count;
++}
++static DEVICE_ATTR_RW(global_brightness);
++
++static ssize_t autonomous_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	return scnprintf(buf, PAGE_SIZE, "%d\n", led->autonomous);
++}
++
++static ssize_t autonomous_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	int ret, autonomous;
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if ((sscanf(buf, "%i", &autonomous)) != 1)
++		return -EINVAL;
++
++	ret = omnia_led_autonomous_set(led, autonomous);
++	if (ret < 0)
++		return ret;
++
++	led->autonomous = autonomous;
++	return count;
++}
++static DEVICE_ATTR_RW(autonomous);
++
++static ssize_t color_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	return scnprintf(buf, PAGE_SIZE, "%d %d %d\n", led->r, led->g, led->b);
++}
++
++static ssize_t color_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	int ret, r, g, b;
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if ((sscanf(buf, "%i %i %i", &r, &g, &b)) != 3)
++		return -EINVAL;
++
++	ret = omnia_led_color_set(led, r, g, b);
++	if (ret < 0)
++		return ret;
++
++	led->r = r;
++	led->g = g;
++	led->b = b;
++	return count;
++}
++static DEVICE_ATTR_RW(color);
++
++
++static const struct of_device_id of_omnia_match[] = {
++	{ .compatible = "turris-leds,omnia", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, of_omnia_match);
++
++static int omnia_probe(struct i2c_client *client,
++					const struct i2c_device_id *id)
++{
++	struct omnia_led_mcu *chip;
++	struct omnia_led *leds;
++	struct omnia_platform_data *pdata;
++	int i, err;
++
++	pdata = dev_get_platdata(&client->dev);
++
++	if (!pdata) {
++		pdata = omnia_dt_init(client);
++		if (IS_ERR(pdata)) {
++			dev_warn(&client->dev, "could not parse configuration\n");
++			pdata = NULL;
++		}
++	}
++
++	chip = devm_kzalloc(&client->dev, sizeof(*chip),
++				GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++	leds = devm_kzalloc(&client->dev, MAX_LEDS * sizeof(*leds),
++				GFP_KERNEL);
++	if (!leds)
++		return -ENOMEM;
++
++	i2c_set_clientdata(client, chip);
++
++	mutex_init(&chip->mutex);
++	chip->client = client;
++	chip->leds = leds;
++
++	for (i = 0; i < MAX_LEDS; i++) {
++		leds[i].led_num = i;
++		leds[i].chip = chip;
++		INIT_WORK(&leds[i].work, omnia_led_work);
++
++		/* Platform data can specify LED names and default triggers */
++		if (pdata && i < pdata->leds.num_leds) {
++			if (pdata->leds.leds[i].name)
++				snprintf(leds[i].name,
++					 sizeof(leds[i].name), "omnia-led:%s",
++					 pdata->leds.leds[i].name);
++			if (pdata->leds.leds[i].default_trigger)
++				leds[i].led_cdev.default_trigger =
++					pdata->leds.leds[i].default_trigger;
++		}
++		if (!pdata || i >= pdata->leds.num_leds ||
++						!pdata->leds.leds[i].name)
++			snprintf(leds[i].name, sizeof(leds[i].name),
++				 "omnia-led:%d", i);
++
++		leds[i].led_cdev.name = leds[i].name;
++		leds[i].led_cdev.brightness_set = omnia_led_set_async;
++
++		err = led_classdev_register(&client->dev, &leds[i].led_cdev);
++		if (err < 0)
++			goto exit;
++
++		err = device_create_file(leds[i].led_cdev.dev,
++						&dev_attr_autonomous);
++		if (err < 0) {
++			dev_err(leds[i].led_cdev.dev,
++				"failed to create attribute autonomous\n");
++			goto exit;
++		}
++
++		err = device_create_file(leds[i].led_cdev.dev,
++						&dev_attr_color);
++		if (err < 0) {
++			dev_err(leds[i].led_cdev.dev,
++				"failed to create attribute color\n");
++			goto exit;
++		}
++
++		/* Set AUTO for all LEDs by default */
++		leds[i].autonomous = 0;
++		omnia_led_autonomous_set(&leds[i], 1);
++
++		/* Set brightness to LED_OFF by default */
++		omnia_led_brightness_set(&leds[i], LED_OFF);
++
++		/* MCU default color is white */
++		leds[i].r = 255;
++		leds[i].g = 255;
++		leds[i].b = 255;
++	}
++
++	err = device_create_file(&client->dev, &dev_attr_global_brightness);
++	if (err < 0) {
++		dev_err(&client->dev,
++			"failed to create attribute global_brightness\n");
++		goto exit;
++	}
++
++	return 0;
++
++exit:
++	device_remove_file(&client->dev, &dev_attr_global_brightness);
++	while (i--) {
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_color);
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_autonomous);
++
++		led_classdev_unregister(&leds[i].led_cdev);
++	}
++
++	return err;
++}
++
++static int omnia_remove(struct i2c_client *client)
++{
++	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++	int i;
++
++	device_remove_file(&client->dev, &dev_attr_global_brightness);
++
++	for (i = 0; i < MAX_LEDS; i++) {
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_color);
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_autonomous);
++
++		led_classdev_unregister(&chip->leds[i].led_cdev);
++	}
++
++	return 0;
++}
++
++static struct i2c_driver omnia_driver = {
++	.driver = {
++		.name	= "leds-omnia",
++		.of_match_table = of_match_ptr(of_omnia_match),
++	},
++	.probe	= omnia_probe,
++	.remove	= omnia_remove,
++	.id_table = omnia_id,
++};
++
++module_i2c_driver(omnia_driver);
++
++MODULE_AUTHOR("Tomas Hlavacek <tmshlvck@gmail.com>");
++MODULE_DESCRIPTION("Turris Omnia LED driver");
++MODULE_LICENSE("GPL v2");
++

From eec3759ba0dd77a2709b40538827dac5a8722e85 Mon Sep 17 00:00:00 2001
From: Michael Altizer <xiche@verizon.net>
Date: Wed, 28 Dec 2016 19:01:11 -0500
Subject: [PATCH 4/4] mvebu: add uBoot environment info for Turris Omnia

---
 package/boot/uboot-envtools/files/mvebu | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/package/boot/uboot-envtools/files/mvebu b/package/boot/uboot-envtools/files/mvebu
index 2bbbc236614..b11fc9c7ba4 100644
--- a/package/boot/uboot-envtools/files/mvebu
+++ b/package/boot/uboot-envtools/files/mvebu
@@ -26,6 +26,9 @@ armada-385-linksys-rango)
 armada-xp-linksys-mamba)
 	ubootenv_add_uci_config "/dev/mtd1" "0x0" "0x40000" "0x20000"
 	;;
+armada-385-turris-omnia)
+	ubootenv_add_uci_config "/dev/mtd0" "0xC0000" "0x10000" "0x40000"
+	;;
 esac
 
 config_load ubootenv
